## 📚 1. 네트워크 보안이란 무엇인가?
네트워크 통신은 제 3자가 개입할 수 있는 불안전한 매체를 통해 메시지를 주고 받는다. 

네트워크 통신에서는 다음과 같은 고려사항이 존재한다
1. 도청(interception): 경로 상의 공격자가 메시지 내용을 훔쳐볼 수 있다
    - 암호화
2. 위장(Camouflage): 송신자 또는 수신자를 위장하여 메시지를 보내거나 받을 수 있다
    - 메시지 인증 코드 or 전자서명
3. 변조(falsification): 중간에서 메시지 내용이 변경될 수 있다
    - 메시지 인증 코드 or 전자서명
4. 사후 부인(posthumous denial): 송신자가 보낸 메시지 내용을 부인할 수 있다
    - 전자서명

안전한 통신에 요구되는 특성은 다음과 같다
- 기밀성(confidentiality)
    - 송신자와 지정된 수신자만이 메시지 내용을 이해할 수 있어야 한다
    - 도청자가 메시지를 가로채더라도 해석할 수 없도록 암호화되어 있어야 한다
- 메시지 무결성(message integrity)
    - 메시지는 중간에 변경되어서는 안된다
    - 체크섬(checksum)을 확장하여 무결성을 제공할 수 있다
- 종단점 인증(endpoint authentication)
    - 통신에 참여하는 상대가 누구인지 확인하기 위해 신원을 확인할 수 있어야 한다
    - 서버는 자원에 접근하는 사용자가 자원의 소유자인지 확인할 수 있어야 한다
- 운영 보안(operational security)
    - 네트워크 공격자는 호스트 컴퓨터에 다양한 방식으로 보안 공격을 시도할 수 있다
    - 방화벽이나 침입자 감지 시스템은 이를 예방해준다

## 📚 2. 암호의 원리 : 기밀성(confidentiality)
- 평문(plain text, cleartext)
    - 암호화되지 않은 원래 형태의 메시지
    - ex. "Bob, I love you. Alice."
- 암호문(ciphertext)
    - 평문에 암호화 알고리즘을 사용해 암호화
    - 다른 침입자가 해석할 수 없다
    - 평문(m) + 키($K_A$) = 암호문($K_A(m)$)
- 복호화
    - 암호문($K_A(m)$) + 키($K_B$) = $K_B(K_A(m))$ = $m$
- 대칭키 시스템
    - 송신자와 수신자는 동일한 키를 사용
    - 키는 둘 사이의 비밀
- 공개키 시스템
    - 한 쌍의 키를 사용
    - 공개키는 누구나 알 수 있는 키
    - 개인키는 송/수신자 중 한 명만 가짐

### 2.1 대칭키 암호화
#### 1) 카이사르 암호(Caesar Cipher)
- 평문의 각 철자를 알파벳 순서로 k번째 뒤에 오는 철자로 대치
- 카이사르 암호는 25가지 키만이 가능하기 때문에 해독하는 데 시간이 오래 걸리지 않는다는 문제가 있다
- k=3
    - a -> d, b -> e ...
    - ex. "bob, i love you. alice." -> `"ere, l oryh brx. dolfh."`

#### 2) 단일 문자 대응 암호(monoalphabetic cipher)
- 일정한 규칙에 따라 대치하는 대신, 각 철자들을 고유한 대응 글자로 변환
- 첫 글자는 26개 글자에, 두 번째 글자는 나머지 25개 글자에 ... 대응할 수 있음
    - $26!$ 가지 키가 가능하다
- 통계 분석을 통해 자주 나오는 철자나 단어 등을 통해 유추할 수 있다는 문제가 있다
- 침입자가 갖는 정보에 따라 세 가지 시나리오를 생각해볼 수 있다
    1. 암호문만을 이용한 공격(ciphertext-only attack)
        - 어떠한 사전 정보도 없이 가로챈 암호문에만 접근할 수 있는 경우
        - 통계분석을 통해 해석할 수 있다
    2. 알려진 평문 공격(known-plaintext attack)
        - 암호문의 일부 매핑 정보를 알고 있는 경우
        - 경우의 수가 확연히 줄어들게 된다
    3. 선택 평문 공격(chosen-plaintext attack)
        - 특정 평문 메시지를 선택하여 이에 대응하는 암호문을 얻을 수 있는 경우
        - 발전된 암호화 기법들에서는 선택 평문 공격이 유효하지 않음

#### 3) 다중 문자 대응 암호화(polyalphabetic encryption)
- 여러 개의 단일 문자 대응법을 가지고 위치에 따라 다른 단일 문자 대응 암호를 사용
- 같은 문자라도 위치에 따라 다르게 암호화됨

#### 4) 대칭키 암호화: 블록 암호화(block ciphers)
- PGP(보안 전자 메일), SSL(보안 TCP), IPSec(보안 네트워크 계층 전송) 등에 사용
- 메시지를 k비트의 블록 단위로 암호화
    - ex. k=64라면, 64비트 단위로 암호화
- k비트 블록의 평문을 k비트 블록의 암호문으로 대응
    - ex. k=3이라면, 3비트 입력에 대응하는 3비트 출력으로 매핑시켜줌
    - 일대일 사상을 가진다
- 키는 사상표가 되고, 사상표를 이용해 메시지를 암호화 및 복호화할 수 있다
- 크지 않은 k에 대해서도 입력 가능한 모든 블록에 대응하는 테이블을 유지하기 어렵다
    - ex. k=64라면, 송/수신자는 $2^{64}!$ 크기의 테이블을 유지해야 한다
    - 모든 입력 블록과 출력 블록 간의 사상이 미리 결정되어 있음
- 해결책
    - k=64라면, 64비트를 통째로 암호화하는 것이 아닌, 8비트씩 끊어서 암호화
    - k=8인 테이블을 8개 관리하면 되므로, $8\times 2^8!$ 크기의 테이블을 유지하면 된다
    - 각각의 8비트 암호들은 스크램블러를 통해 순서가 변경되고 위 과정을 n회 반복
    - `DES(Data Encryption Standard)`, `3DES`, `AES(Advanced Encryption Standard)` 등이 있음
    - 각각의 표준들은 비트열을 키로 사용
        - DES : `56비트의 키`, `64비트 블록`
        - AES : `128, 192, 256비트의 키`, `128비트 블록`
    - 키는 알고리즘 내부에서 미니 테이블의 사상과 순열을 결정

#### 5) 암호화 블록 체이닝(CBC, Cipher Block Chaining)
두 개 이상의 평문 블록이 동일하다면 원문을 추측할 수 가능성이 생긴다. 평문 블록의 내용이 동일하더라도 다른 암호문 블록이 생성되도록 임의성(randomness)을 추가하면 원문을 추측하기 어렵지 않을까?

##### 아이디어
- $K_S$: 키가 S인 블록 암호화 알고리즘
- $r(i)$: i번째 블록을 위한 k비트 길이의 임의의 수
- $c(i) = K_S(m(i) \oplus r(i))$
    - 평문과 임의 수를 XOR 연산한 후, 키를 이용해 암호화
    - 송신자는 $c(1)$, $r(1)$, $c(2)$, $r(2)$, ... 같은 방식으로 송신
- 공격자가 $r(i)$와 $c(i)$를 알더라도 $K_S$없이는 복호해낼 수 없음
- 동일한 내용이더라도 임의의 수와 XOR 연산을 했기 때문에 서로 다른 비트를 가진다
- 문제
    - 송신자는 임의 문자열 $r(i)$를 함께 보내야하므로 전송량이 2배가 된다

##### 해결
- 첫 번째 메시지와 임의의 수(초기화 벡터, IV, Initialization Vector)를 단 한번만 전송
- 이후에는 `임의의 수로 직전에 계산된 암호화 블록을 대신 사용`
- 과정
    1. 송신자는 IV를 평문 형태로 수신자에게 송신
    2. 송신자는 $c(1) = m(1) \oplus c(0)$을 계산
    3. $c(1) = K_S(m(1) \oplus c(0))$을 수신자에게 전달
    4. $i$번째 블록에 대해 송신자는 $c(i) = K_S(m(i) \oplus c(i-1))$을 계산하여 암호화 블록을 생성
- 수신자는 여전히 원래 메시지를 복구 가능
- 평문이 동일하더라도 서로 다른 임의 문자열로 인해 서로 다른 암호문이 생성
- 송신자는 IV를 암호화하지 않더라도 공격자는 $K_S$를 모르므로 암호문 블록을 해독할 수 없음
- 송신자는 IV 하나만을 추가하면되므로 대역폭 증가량이 미미함

### 2.2 공개키 암호화
두 통신 관계자가 암호화와 복호화를 하기 위해서는 공통의 비밀키를 필요로 한다. 이를 위해서는 송신자와 수신자는 `암호화와 복호화를 위해 필요한 키`를 공유해야 한다.

- 공개키 암호화 방식은 하나의 비밀키를 사용하지 않고 `메시지 수신자`가 2개의 키를 가진다. 
- 공개키(public key) : 모든 사람에게 알려진 키, $K^+_B$
- 개인키(private key, secret key) : 수신자만이 가진 키, $K^-_B$
- 과정
    1. 송신자는 수신자의 공개키를 가져온다
    2. (모든 사람이 알고 있는) 수신자의 공개키와 이미 알려진 암호화 알고리즘을 이용해 메시지 $m$을 암호화한다, $K^+_B(m)$
    3. 수신자는 암호화된 메시지($K^+_B(m)$)와 개인키, 이미 알려진 암호화 알고리즘을 이용해 복호화한다, $K^-_B(K^+_B(m))=m$
- 특징
    - $K^-_B(K^+_B(m))=m$ = $K^+_B(K^-_B(m))=m$
- 문제
    1. 공격자는 이미 알려진 알고리즘과 공개키를 이용해 자신의 메시지를 암호화하는 `선택 평문 공격`을 할 수 있음
    2. 암호키는 이미 공개되어 있기 때문에 누구든 송신자를 사칭해 메시지를 보낼 수 있음

#### 1) RSA(Rivest, Adi Shamir, Leonard Adleman) 알고리즘
- 공개키 암호화와 거의 동의어처럼 취급됨
- modulo-n 연산이 많이 사용됨

$$
[(a\ mod\ n)\ +\ (b\ mod\ n)\ =\ (a\ +\ b)\ mod\ n] \\
[(a\ mod\ n)\ -\ (b\ mod\ n)\ =\ (a\ -\ b)\ mod\ n] \\
[(a\ mod\ n)\ \cdot\ (b\ mod\ n)\ =\ (a\ \cdot\ b)\ mod\ n] \\
(a\ mod\ n)^d\ mod\ n\ =\ a^d\ mod\ n
$$

##### 공개키 & 개인키의 생성
1. 두 개의 큰 소수 p와 q를 선택한다
    - 값이 커질수록 RSA를 깨기 어렵지만, 암호화와 복호화를 수행하는 데 걸리는 시간이 오래 걸림
2. $n = pq,\ z = (p-1)(q-1)$ 식을 계산
3. z와 서로소인 수 e를 선택($e<n$)
4. $ed\ mod\ z\ =\ 1$인 수 $d$를 찾는다
- 모든 사람이 사용할 수 있는 밥의 공개키 $K^+_B$는 숫자 쌍 $(n, e)$가 된다
- 수신자의 개인키 $K^-_B$는 숫자 쌍 $(n, d)$가 된다
- 과정
    1. 송신자가 정수 m (m < n)인 비트를 전송하려 한다
        - 송신자는 $m^e$를 수행하고, n으로 나누었을 때의 나머지를 계산한다
        - 송신자가 보내는 평문 메시지 m의 암호값 c는 $c = m^e\cdot mod\ n$
    2. 송신자가 수신자에게 암호값 c를 전달한다
    3. 수신자는 개인키를 이용해 복호화를 수행한다
        - $m = c^d \cdot mod\ n$
- 예시
    1. p=5, q=7을 선택한다
    2. $n=5\times 7=35,\quad z=(5-1)\times (7-1)=24$
    3. 24와 서로소인 임의의 수 $e=5$를 선택
    4. $5\times 29\ mod\ 24 = 145 \mod 24=1$로, $d=29$를 사용
        - 공개키: $K^+_B=(35,\ 5)$
        - 개인키: $K^-_B=(35,\ 29)$
- 동작 원리
    1. 메시지 m은 modulo-n 연산을 사용해 e를 제곱함
        - $c = m^e \times mod\ n$
    2. 복호화는 이 값에 다시 modulo-n 연산을 사용해 d를 제곱함
        - $(m^e \times mod\ n)^d mod\ n=m^{ed}\ mod\ n$
        - $m^{ed}\ mod\ n = m^{ed\ mod\ z}\ mod\ n = m^1\ mod\ n=m\ mod\ n = m$

```
Diffie-Hellman 알고리즘

* 임의 길이의 메시지를 암호화할 수 없다는 점에서 RSA만큼 유용하지는 않지만 대칭 세션키(하이브리드 암호 방식)를 생성할 때 사용 가능
```

#### 2) 세션키 (하이브리드 암호 방식)
- 공개키 방식인 RSA는 지수 연산의 시간이 많이 필요
- 대칭키 방식인 암호화/복호화 속도가 100배에서 최대 10,000배 더 빠르다
- `송신자`는 세션키 $K_S$를 선택한다
    - $K_S$는 속도가 빠른 대칭키를 사용한다
- 대칭키를 상대방에게 알려주기 위해 `수신자의 공개키`를 이용해 암호화한다
    - $c = (K_S)^e\ mod\ n$
- 수신자는 RSA로 암호화된 c를 받고, 복호화를 통해 `세션키` $K_S$를 얻는다
- 이후로는 `세션키(대칭키)`를 이용해 통신을 주고 받는다

## 📚 3. 전자서명 : 메시지 무결성(message intigrity)
메시지 무결성(메시지 인증), 전자서명(digital signature), 종단점 인증(end-point authentication)에 대해서 공부

##### 문제의 정의
수신자는 받은 메시지가 송신자가 보낸 것이라 믿고 있다. 메시지를 인증하기 위해 수신자는 다음을 확인해야 한다.
1. 메시지는 공격자가 아닌 송신자가 보낸 것이 맞다
2. 메시지는 변조되지 않았다

### 3.1 암호화 해시 함수
- 해시 함수: 입력 m을 받아서 고정된 크기 문자열인 해시 $H(m)$을 계산
    - $H(x) = H(y)$가 되는 서로 다른 두 메시지 $x$와 $y$를 찾는 것은 불가능하다ㅓ
- 보안을 위해서는 체크섬보다 더욱 강력한 해시 함수가 필요
    - 체크섬은 동일한 문자열이지만 순서가 다른 경우 동일한 값을 가질 수 있음

### 3.2 메시지 인증 코드(MAC, Message Authentication Code)
- 메시지 무결성을 위해서는 암호화 해시 함수의 사용 외에도 송신자와 수신자의 대칭키를 공유할 필요가 있음
- MAC은 암호화 알고리즘을 필요로 하지 않음
- 대체로 통신 개체들은 무결성을 신경쓰지 기밀성을 고려하지 않음
    - 누군가 메시지를 볼 수 있더라도, 메시지의 내용을 수정할 수는 없음
- MAC은 복잡한 암호화 알고리즘을 포함시키지 않고도 서로에게 보내는 메시지를 인증할 수 있음
- 가장 많이 사용되는 표준은 HMAC

### 3.3 전자서명(Digital Signature)
- 송신자가 메시지에 서명할 때 수신자는 고유한 무언가를 메시지에 포함시켜야 함
- MAC은 수신자 또한 동일한 서명을 만들 수 있기 때문에 MAC은 전자서명으로 적합하지 않음
- 공개키 암호화 기숨ㄹ은 전자서명의 구현에 적합
- 전자서명에서는 메시지를 개인키(비밀키)가 아닌 공개키를 이용해 암호화($K^-_B(m)$)
    - 전자서명을 보내는 입장에서는 기밀성보다는 입증이 가능하고 위조할 수 없게 하는 것이 목적
- 전자서명에서는 메시지(서명)를 만들 때 $K^-_B$를 이용해 암호화
- 개인키 $K^-_B$를 알고 있는 사람은 송신자뿐이기 때문에 사후 부정을 할 수 없음
- 중간에서 공격자가 메시지의 내용을 변경하더라도 메시지의 내용을 변경하면 서명이 변경되기 때문에 더 이상 유효하지 않음
- 전자서명은 변조, 메시지 무결성을 제공
- 문제점
    - 암호화와 복호화를 위한 연산이 많다
- 해결책
    - 해시함수를 이용해 먼저 해시값을 구한 후, 이 값과 암호화 알고리즘을 사용하면 연산량을 줄일 수 있음

```
MAC(Message Authentication Code)
* 공개키 암호화나 대칭키 암호화가 사용되지 않음

전자서명(Digital Signature)
* 메시지의 해시값을 얻고 개인키를 이용해 암호화
```

## 📚 4. 종단점 인증(End-point Authentication)
- 종단점 인증(End-point Authentication)
    - 하나의 통신 개체가 자신의 신원을 네트워크 상에서 증명하는 작업
- 인증 프로토콜(Authenticaiton Protocol)은 교환된 메시지와 데이터만을 기반으로 수행되어야 한다
- 인증된 후에 송신자와 수신자는 실제 작업을 수행할 수 있음

### 4.1 인증프로토콜 ap1.0
- 송신자 입장에서 수신자에게 자신이 정당한 수신자라고 전달
- 하지만 이런 메시지는 아무나 보낼 수 있다는 문제가 있음

### 4.2 인증 프로토콜 ap2.0
- 수신자는 송신자의 출발지 주소를 통해 송신자를 인증할 수 있음
- 공격자가 출발지 주소를 임의로 변경하여 수신자에게 메시지를 전달할 수 있음
    - IP 스푸핑
- 라우터가 임의로 변경된 송신자의 주소를 검증할 수도 있지만, 실질적으로 라우터가 주소를 검증하지 않고 강제할 수 없음

### 4.3 인증 프로토콜 ap3.0
- 인증을 위한 비밀번호를 사용
- 비밀번호는 인증자와 인증 받는 사람 간에 공유된 비밀
- 누군가 통신을 도청하면 비밀번호를 알아낼 수 있음

### 4.4 인증 프로토콜 ap3.1
- ap3.0의 비밀번호를 암호화
- 공격자 입장에서는 비밀번호 자체를 알아내지 못하더라도 암호화된 암호 자체를 도청하여 수신자에게 메시지를 보낼 수 있음

### 4.5 인증 프로토콜 4.0
- TCP 서버가 수신받은 SYN 세그먼트가 이전 연결 SYN 세그먼트의 복사본이라면 연결을 수락하지 않음
- 서버는 오랫동안 사용되지 않은 초기 순서번호를 선택해서 클라이언트에게 번호를 보냄
- 클라이언트는 이 번호를 담은 ACK 세그먼트 응답을 대기

#### 1) 넌스(nonce)
- 넌스는 프로토콜이 평생에 한 번만 사용하는 숫자
- 프로토콜이 한 번 어떤 넌스를 사용하면 이 숫자를 절대 다시 사용하지 않음
- 과정
    1. 송신자는 "나는 송신자다"를 수신자에게 송신
    2. 수신자는 넌스 $R$을 선택하고, 송신자에게 응답
    3. 송신자는 대칭키인 $K_{A-B}$를 사용해 넌스를 암호화
    4. 암호화된 넌스 $K_{A-B}$는 수신자에게 보내짐
    5. 수신자는 받은 메시지를 복호화
    6. 복호화된 넌스가 송신자에게 보낸 것과 같다면 송신자를 인증

## 📚 5. 전자우편의 보안
- 인터넷 프로토콜 스택 위쪽 네 개 계층의 어느 곳이든 보안 서비스를 제공하는 것이 가능
- 하나의 계층에서 보안 기능을 제공한다면?
    1. 하위 계층에서 보안을 제공하더라도 윗 계층의 입장에서는 인증 과정이 필요할 수 있음
        - ex. 애플리케이션 계층의 로그인
    2. 프로토콜 스택의 상위 계층에서 보안 서비스를 포함한 새로운 인터넷 서비스를 구현하는 일이 쉬워짐
        - 하위 계층 보안 프로토콜에 의존하지 않고 상위 계층에서 독립적으로 자체적인 보안 기능을 추가할 수 있음

전자우편 시스템에서 어떤 보안 특성이 필요할까?
1. 기밀성 : 인증된 사용자만 메시지를 읽을 수 있다
2. 송신자 인증 : 수신자는 송신자가 보낸 메시지라 확신할 수 있다
3. 메시지 무결성 : 메시지가 전송되는 동안 변조되지 않는다
4. 수신자 인증 : 인증된 사용자만이 송신된 메시지를 읽을 수 있다

### 5.1 보안 전자우편
#### 1) 기밀성만을 생각하는 경우
- 대칭키 기술(DES, AES) : 수신자가 복호화
- 송신자와 수신자만이 알 수 있는 대칭키를 배포해야 하는 근본적인 어려움이 있음 -> 공개키 방식을 통해 교환 가능
- 공개키 기술(RSA) : 길이가 긴 메시지에 대해 비효율적이라는 문제가 존재
- 하이브리드 암호화(세션키) : 비대칭키를 이용해 대칭키를 교환하고 실질적으로 대칭키를 이용해 암호화와 복호화를 진행

#### 2) 인증과 무결성에만 관심이 있는 경우
- 전자서명과 메시지 요약문(해시)를 이용
- 송신자는 해시 계산된 후 키를 이용해 암호화된 $K^-_A(H(m))$를 전송
- 과정
    1. 송신자는 메시지에 해시를 적용 -> $H(m)$
    2. 해시 함수 결과와 개인키 $K^-_A$로 암호화 수행 -> $K^-_A(H(m))$
    3. `메시지와 전자서명`을 결합해 패킷을 생성
    4. 패킷을 수신자의 전자우편 주소로 송신
    5. 수신자는 받은 패킷에 $K^+_A$을 적용
    6. 메시지에 해시 함수 $H$를 적용하고 송신자가 보낸 전자서명과 비교
    7. 수신자는 송신자가 보낸 메시지가 변조되지 않음을 확신

### 5.2 PGP(Pretty Good Privacy)
- PGP는 전자우편 암호화 기법의 예시
- 버전에 따라 PGP는 MD5나 SHA를 메시지에 사용
- PGP가 설치되면 소프트웨어는 사용자를 위한 공개키 쌍을 생성
- PGP는 `전자서명`, `암호화`, 또는 `전자서명 + 암호화` 방식을 제공

## 📚 6. TCP 연결의 보안 : TLS
- 이 절에서는 TCP에 어떻게 기밀성, 데이터 무결성, 종단점 인증 등의 보안 서비스를 적용할 수 있는지에 대해 공부한다
- 이렇게 향상된 TCP는 흔히 TLS(Transport Layer Security)라고 부른다
- https를 이용한다면 TLS를 이용하는 것
- TLS가 필요한 예시 : 사용자가 물품을 구매
    - 기밀성이 제공되지 않음 : 공격자가 주문 내용을 가로채서 신용 카드 정보를 얻을 수 있음. 공격자는 주문자의 돈으로 구매할 수 있음
    - 무결성이 없음 : 공격자는 주문자의 주문을 수정해서 주문자의 의사와 관계없이 물품을 구매할 수 있음
    - 서버 인증이 제공되지 않음 : 공격자는 임의의 사이트를 만들어 주문자의 정보를 획득할 수 있음
- TLS는 TCP를 향상함으로써 이러한 문제를 해결
- TLS는 http 외에도 TCP 상에서 일어나는 어떠한 애플리케이션에서도 사용될 수 있음
- 애플리케이션은 TLS를 위해 SSL 클래스/라이브러리를 지원

### 6.1 TLS 개요
- TLS의 필요성을 위해 단순화된 `almost-TLS` 버전을 설명
-  almost-TLS는 `handshake`, `키 유도(key derivation)`, `데이터 전송(data transfer)`, 세 단계로 구성

<br>

가정 : 클라이언트는 개인키/공용키 쌍을 가지며, 신원을 공개키와 관련하여 인증받음

#### 1) handshake
1. 클라이언트는 TCP 연결을 설정
2. 자신이 진짜 클라이언트인지 확인
3. 서버측은 TLS 세션에 필요한 모든 대칭키를 생성하기 위해 주 비밀키(master secret key)를 클라이언트에게 전송
4. TCP 연결이 성립되면 클라이언트는 서버에게 `hello 메시지`를 보냄
5. 클라이언트는 클라이언트의 `공개키를 담은 인증서`로 응답
6. 인증서는 CA에 의해 인증받기 때문에, 서버는 인증서 내의 공개키가 클라이언트의 것임을 믿을 수 있음
7. 서버는 MS(Master Secret)를 생성하고, 이를 클라이언트의 공개키로 암호화 -> EMS(Encrpyted Master Secret)를 생성
8. EMS는 클라이언트에게 전송되고, 클라이언트는 자신의 개인키를 이용해 EMS를 복호화, MS를 획득한다
9. 클라이언트와 서버 모두 TLS 세션의 MS를 알게 된다

#### 2) 키 유도 (key derivation)
1. 클라이언트와 서버가 공유한 MS는 이후의 모든 암호화와 데이터 무결성 검사를 위한 대칭 세션키(대칭키)로 사용
    - 클라이언트와 서버는 일반적으로 다른 암호화 키를 사용하고, 암호화와 무결성 검사에도 서로 다른 키를 사용하는 것이 안전
        - $E_B$ : 서버가 클라이언트에게 보내는 데이터에 대한 세션 암호키
        - $M_B$ : 서버가 클라이언트에게 보내는 데이터에 대한 세션 HMAC 키
        - $E_A$ : 클라이언트가 서버에게 보내는 데이터에 대한 세션 암호키
        - $M_A$ : 클라이언트가 서버에게 보내는 데이터에 대한 세션 HMAC 키

클라이언트와 서버는 MS로부터 각자 4개의 키를 생성한다. 이것은 단순히 MS를 4개의 키로 쪼개면 된다. 키 유도 단계의 마지막에 이르면, 클라이언트와 서버는 4개의 키를 갖게 된다.
- 2개의 암호화 키는 데이터 암호화에 사용
- 2개의 HMAC키는 데이터 무결성 검사를 위해 사용

#### 3) 데이터 전송
- 클라이언트와 서버는 4개의 세션키($E_B, M_B, E_A, M_A$를 공유하고 있기 때문에, 클라이언트와 서버는 TCP 연결을 통해 서로에게 안전한 데이터를 보낼 수 있음
- TCP가 바이트 스트림 프로토콜이므로, TLS가 애플리케이션 데이터를 끊임없이 암호화하고 암호화된 데이터를 TCP에 계속적으로 전달
- TLS는 데이터 스트림을 레코드(record) 단위로 쪼개고 각 레코드에 HMAC을 덧붙여 `레코드+HMAC`을 암호화
- HMAC을 생성하기 위해 레코드 데이터+키$M_B$를 해시 함수에 넣는다
- 레코드+HMAC을 암호화하기 위해 세션 암호화 키 $E_B$를 사용
- 서버는 순서 번호 카운터를 유지할 때 레코드 자체에 포함시키는 것이 아니라 HMAC을 계산할 때 포함시킴
    - `HMAC키(M_B) + 현재 순서번호`를 합친 결과의 해시값

#### 4) TLS 레코드
- TLS 레코드는 `타입`, `버전`, `길이`, `데이터`, `HMAC`을 가진다
- `타입, 버전, 길이`는 암호화되지 않고, `데이터`와 `HMAC`만 암호화된다

### 6.2 TLS의 완전한 개념
#### 1) TLS handshaking
- TLS는 특정 대칭키 알고리즘이나 공개키 알고리즘을 사용하도록 강제하지 않음
- TLS는 클라이언트와 서버가 handshaking 단계에서 사용할 암호화 알고리즘에 합의하게 함
- 클라이언트와 서버는 서로에게 넌스를 보내고, 넌스는 세션키($E_B, M_B, E_A, M_A$)를 생성할 때 사용됨

#### 2) TLS handshaking 과정
1. 클라이언트는 넌스와 함께 자신이 지원하는 암호화 알고리즘 목록을 송신
2. 서버는 목록으로부터 대칭키, 공개키, HMAC키와 함께 HMAC 알고리즘을 선택
    - 서버는 자신의 선택 결과와 인증서, 서버 넌스를 클라이언트에게 응답
3. 클라이언트는 인증서를 확인하고, 서버의 공개키를 알아낸 후 PMS(Pre-Master Secret)을 생성
    - PMS를 서버의 공개키로 암호화하여 서버에게 전송
4. 클라이언트와 서버는 같은 키 유도 함수를 사용해 PMS와 넌스로부터 독립적인 MS를 계산
    - MS는 2개의 암호화 키와 2개의 HMAC 키를 생성하기 위해 분할
    - 선택된 대칭 암호화가 CBS(3DES나 AES)를 이용한다면 양측을 위해 2개의 IV(Initialization Vector)를 MS로부터 획득
    - 이후부터 클라이언트와 서버 간 모든 메시지는 HMAC을 이용해 암호화되고 인증됨
5. 클라이언트는 모든 handshake 메시지의 HMAC을 전송
6. 서버는 모든 handshake 메시지의 HMAC을 전송

#### 3) 연결 종료
1. 단순히 TCP 연결을 끊음으로써 TLS 세션을 종료하게 함
    - 단순히 클라이언트가 서버에게 FIN 요청을 보냄
    - 문제 : 절단 공격 (truncation attack)
        - 공격자가 임의로 TCP FIN 요청을 보내 연결 설정을 종료할 수 있음
    - 해결 : 레코드의 타입 필드에 레코드가 TLS 세션 종료를 수행할 것인지를 표시
        - 만일 서버가 종료 TLS 레코드를 받기 전에 TCP FIN을 받게 되면 이상하다는 것을 감지함