## 1. 트랜스포트 계층 서비스 및 개요

- 트랜스포트 계층 프로토콜 : 애플리케이션 프로세스들 간의 논리적 통신 제공
    - 논리적 통신(Logical Communication) : 프로세스들이 동작하는 호스트들이 직접 연결된 것처럼 보이는 것
    - 실제로 호스트들은 수 많은 라우터와 링크를 통해 연결될 수 있음
- 트랜스포트 계층 프로토콜은 종단 시스템에서 구현됨
- 애플리케이션 계층 패킷인 `메시지`를 4계층 `세그먼트(segment)`로 변환
    - 애플리케이션 메시지를 세그먼트로 변환하기 위해 작은 조각으로 분할
    - 각각의 조각에 트랜스포트 계층 헤더를 추가
- 애플리케이션은 두 개 이상의 트랜스포트 계층 프로토콜을 사용 가능
    - 인터넷은 TCP와 UDP를 사용

### 1.1 트랜스포트 계층과 네트워크 계층 사이의 관계

<hr>

#### 1) 트랜스포트 계층 프로토콜과 네트워크 계층 프로토콜의 비교
트랜스포트 계층은 네트워크 계층 바로 상위에 존재한다
- 트랜스포트 계층 프로토콜 : 프로세스들 사이의 논리적 통신을 제공
- 네트워크 계층 프로토콜 : 호스트들 사이의 논리적 통신을 제공

#### 2) 트랜스포트 계층 프로토콜의 역할
- 트랜스포트 계층 프로토콜은 애플리케이션에서 네트워크 경계까지 메시지를 운반
- 네트워크 계층에서 애플리케이션 프로세스로 메시지를 운반
- 트랜스포트 계층 프로토콜은 패킷이 네트워크에서 어떻게 이동하는지 알 수 없음
- 중간 라우터는 트랜스포트 계층에 대한 정보를 알 수 없음 -> 캡슐화
- 트랜스포트 계층은 네트워크 계층 프로토콜의 제약을 받음
    - 하위 계층에서 지연 보장이나 대역폭 보장을 제공할 수 없다면, 트랜스포트 계층 프로토콜은 프로세스의 메시지에 대해 지연 보장이나 대역폭 보장을 할 수 없음

### 1.2 인터넷 트랜스포트 계층의 개요
<hr>
- TCP/IP 네트워크는 애플리케이션 계층에게 두 가지 프로토콜을 제공 -> TCP, UDP
    - 개발자는 소켓을 생성할 때 TCP와 UDP 중 하나를 선택해야 함
- 세그먼트(segment) : 트랜스포트 계층 패킷

##### 1) IP는 비신뢰적인 서비스
- IP는 호스트 간에 `최선형 전달 서비스(best-effort delivery service)`를 제공
    - 이는 호스트들 간에 세그먼트를 전달하기 위해 최선을 다하지만, `어느 보장도 하지 않음을 의미`
    - 즉, IP는 `비신뢰적인 서비스(unreliable service)`로, 데이터의 무결성을 보장하지 않음

##### 2) UDP & TCP의 기능
- 트랜스포트 다중화(transport multiplexing)와 역다중화(demultiplexing)
    - 종단 시스템 사이의 IP 전달 서비스 -> 종단의 프로세스 간의 전달 서비스로 확장
    - 호스트 <-> 호스트에서 프로세스 <-> 프로세스로 통신 범위를 확장
- 헤더에 오류 검출 필드를 포함하므로 무결성 검사를 제공

#### 3) UDP의 기능
- 다중화 & 역다중화 (multiplexing & demultiplexing) : 프로세스로의 통신 범위 확장
- 무결성 검사 : 헤더에 오류 검출 필드를 포함하여 무결성 검사를 진행
- 비신뢰적 서비스 제공
    - 데이터가 손상되지 않고 목적지 프로세스에 도착하는 것을 보장하지 않음
- 혼잡 제어를 제공하지 않음
    - TCP와 달리 트래픽 조절을 하지 않는다
    - 애플리케이션이 허용하는 한 어떤 속도로도 전송 가능

#### 4) TCP
- 다중화 & 역다중화 (multiplexing & demultiplexing) : 프로세스로의 통신 범위 확장
- 무결성 검사 : 헤더에 오류 검출 필드를 포함하여 무결성 검사를 진행
- 신뢰적 서비스 제공
    - `흐름제어`, `순서번호`, `확인응답`, `타이머` -> 데이터가 순서대로 정확히 전달하는 것을 보장
    - IP의 비신뢰적인 서비스를 신뢰적인 데이터 전송 서비스로 만들어줌
- 혼잡 제어 (congestion control) : 네트워크 전체를 위한 일반 서비스
    - TCP 연결이 과도한 양의 트래픽으로 네트워크 상의 스위치와 링크의 과부하를 방지
    - 혼잡한 네트워크 링크에서 각 TCP 연결이 링크의 대역폭을 공평하게 공유하여 통과하게 함
        - <b><u>송신측의 TCP가 네트워크에 보낼 수 있는 트래픽을 조절</u></b>
- 신뢰적인 데이터 전달 & 혼잡 제어를 제공하는만큼 프로토콜이 복잡함

<br>

## 2. 다중화 & 역다중화 (Transport Multiplexing & Demultiplexing)
- 네트워크 계층이 제공하는 호스트 <-> 호스트 전달에서 프로세스 <-> 프로세스 전달 서비스로 확장
- 다중화와 역다중화는 모든 컴퓨터 네트워크에서 필요
- 하나의 호스트에는 여러 개의 프로세스가 동작
- 네트워크 계층으로부터 데이터를 수신하면 트랜스포트 계층은 동작중인 프로세스 중 하나에 전달할 필요가 있음

### 2.1 트랜스포트 계층 서비스의 동작

<hr>

#### 1) 역다중화 (Demultiplexing)
1. 네트워크 계층에서 소켓을 통해 프로세스로 데이터를 전달
    - 소켓은 하나의 유일한 식별자를 가짐
    - 식별자의 포맷은 TCP 소켓인지, UDP 소켓인지에 따라 달라짐
2. 트랜스포트 계층 세그먼트는 소켓을 구분하기 위해 헤더 정보를 가짐
    - 트랜스포트 계층은 수신 소켓을 식별하기 위해 헤더 정보를 검사

#### 2) 다중화 (Multiplexing)
1. 송신 호스트의 소켓으로부터 데이터를 모으고, 세그먼트를 생성하기 위해 각 데이터에 헤더 정보로 캡슐화
    - 헤더 정보는 수신 호스트에서 역다중화에 사용된다
2. 세그먼트를 네트워크 계층으로 전달

<br>

```
다중화와 역다중화는 모든 계층에서 상위 또는 하위 계층으로 데이터를 받거나 넘길 때 사용된다
```

#### 3) 트랜스포트 계층 다중화의 요구 사항
1. 소켓은 유일한 식별자를 가진다
2. 각 세그먼트는 적절한 소켓을 가리키는 필드가 필요
    - `출발지 포트 번호(source port number field)` & `목적지 포트 번호(destination port number field)`
<br>

#### 4) 포트 번호
- 포트 번호 (Port number) : 0~65535까지 16비트 정수
- 잘 알려진 포트 번호 (Well Known Port number) : 0~1023
    - 이들은 애플리케이션 프로토콜에서 사용되도록 예약되어 있음
    - 애플리케이션을 개발할 때는 포트 번호를 반드시 할당해야 함
    - ex. `spring`: 8080, `react`: 3000
- 소켓은 포트 번호를 할당 받음

이것은 UDP의 기본적인 동작 방식으로 TCP의 다중화/역다중화는 더 많은 의미를 가짐

### 2.2 비연결형 다중화와 역다중화

<hr>

#### 1) UDP의 소켓 식별 ⭐️⭐️⭐️⭐️
UDP 소켓 = `목적지 주소 + 목적지 포트`로 식별

`다른 출발지 IP주소 + 다른 출발지 포트 번호` or `다른 출발지 IP or 다른 출발지 포트 번호` -> 동일한 목적지 IP + 동일한 목적지 포트 번호 -> 같은 목적지 소켓을 통해 동일한 프로세스로 향한다.

<br>

```python
client_socket = socket(AF_INET, SOCK_DGRAM)
```
- UDP 소켓이 생성될 때, 포트 번호를 소켓에 자동으로 할당
- 호스트에서 UDP 포트로 사용하지 않는 1024~65535 사이의 포트 번호를 할당

<br>

만약 특정 포트 번호를 할당하고 싶다면 bind를 이용할 수 있다
```python
client_socket.bind(('', 19157))
```

<br><br>
서버의 Well Known Port 사용

```
일반적 : 서버 측이 특정 포트 번호를 할당하고 클라이언트는 동일한 포트 번호를 사용
Well Known Port 사용 : 클라이언트는 임의의 포트 번호를 사용
```

### 2.3 연결지향형 다중화와 역다중화

<hr>

#### 1) TCP의 소켓 식별 ⭐️⭐️⭐️⭐️
TCP 소켓 = `출발지 주소 + 출발지 포트 + 목적지 주소 + 목적지 포트`로 식별

`다른 출발지 or 다른 출발지 포트` -> 서로 다른 소켓을 향함

<br>

```python
client_socket = socket(AF_INET, SOCK_STREAM)
client_socket.connect((server_name, 12000))
```

<br>

```python
connection_socket, addr = server_socket.accept()
```
서버 프로세스는 연결 요청 세그먼트를 수신하면, 12000 포트 번호에서 대기하고 있다가 새로운 소켓을 생성

### 2.4 지속 연결과 비지속 연결 HTTP

<hr>

#### 1) 지속 연결 HTTP
지속적인 연결 존속 기간동안 클라이언트와 서버는 동일한 서버 소켓을 통해 HTTP 메시지를 교환

#### 2) 비지속 연결 HTTP
- 모든 요청, 응답마다 새로운 TCP 연결이 생성되고 종료
- 비지속 연결 HTTP는 서버 부하에 큰 부하를 준다

## 3. 비연결형 트랜스포트: UDP (User Datagram Protocol)
- UDP가 `어떻게 동작`하고 `무엇인지` 학습

### 3.1 UDP의 특징

<hr>

- UDP는 프로세스 간의 데이터를 넘겨주기 위한 다중화 & 역다중화, 체크섬만을 제공한다
- 3way handshaking (양방향 연결 설정)을 하지 않는다 -> `비연결형`
    - ex. DNS에서 질의 호스트가 응답을 수신하지 못하면, 질의를 다른 DNS 서버에 요청하거나 애플리케이션에 응답을 수신할 수 없음을 통보
- UDP는 혼잡제어를 하지 않음
    - 혼잡제어는 네트워크가 폭주 상태에 빠지는 것을 막기 위해 필요
    - 제어되지 않은 UDP 송신자에 의한 높은 손실률 -> 손실률을 감소시키기 위해 TCP 송신자들의 송신률을 감소시킴
        - UDP -> 높은 손실률
        - TCP -> 세션을 감소시킴

### 3.2 UDP를 사용하는 이유

<hr>

1. 데이터를 보내는 시점에 대한 정교한 제어
    - 프로세스가 데이터를 UDP에 전달하면 별도의 혼잡 제어 없이 데이터를 세그먼트로 만들어 바로 네트워크 계층으로 전달
    - 실시간 애플리케이션 : 최소 전송률을 요구하며, 일부 손실을 허용하더라도 지연에 강한 통신을 필요로 함
    - 수신 여부를 확인할 때까지 재전송을 시도하는 TCP는 UDP에 비해 지연 시간이 발생함

2. 비연결 설정
    - UDP는 연결 설정을 위한 지연이 없음
    - HTTP의 TCP 연결설정은 지연을 야기한다

3. 연결 상태가 없음
    - 연결상태 : `수신 버퍼`, `송신 버퍼`, `혼잡제어 파라미터`, `순서번호`, `확인응답 번호`를 포함
    - UDP는 연결상태가 없기 때문에 위 상태 정보를 저장하지 않음
    - 더 많은 클라이언트를 수용할 수 있음

4. 작은 패킷 헤더 오버헤드
    - TCP: 20바이트의 헤더 오버헤드
    - UDP: 8바이트의 헤더 오버헤드

### 3.3 UDP 사례

<hr>

- 전자 메일, 원격 터미널 접속, 웹, TCP상의 파일 전송 -> `TCP 사용`
- 네트워크 관리 애플리케이션 : 네트워크가 혼잡한 상태에 자주 동작 -> `TCP 사용`
- DNS : TCP 연결 설정 지연을 피하기 위해 -> `UDP 사용`
- 멀티미디어 애플리케이션과 같이 일부 손실을 감안하더라도 지연을 최소화시켜야 하는 경우 UDP를 사용할 수 있다

### 3.4 UDP의 혼잡제어

<hr>

- 애플리케이션 자체에서 신뢰성을 제공한다면 신뢰적인 데이터 전송을 할 수 있다
- ex. 구글의 QUIC 프로토콜 : UDP상에서 애플리케이션 계층에 신뢰성을 구현
- 개발이 어렵지만, 이렇게 되면 애플리케이션 프로세스는 TCP의 혼잡 제어 메커니즘에 의한 전송률 억제를 강요당하지 않을 수 있다

### 3.5 UDP 세그먼트 구조

<hr>

- `출발지 포트 번호` + `목적지 포트 번호` + `길이` + `체크섬` + `애플리케이션 데이터(payload)`
- payload를 제외한 UDP 헤더의 각 필드는 2바이트씩으로 구성됨

### 3.6 UDP 체크섬

<hr>

- UDP 세그먼트 안의 비트에 대한 변경사항이 있는지 검사
- 세그먼트 헤더 안에 있는 모든 16비트 워드(각 필드)를 더하고 1의 보수를 수행 -> 체크섬 필드에 삽입
- 수신측은 헤더의 모든 값을 더해 모든 값이 1이 되는지 확인
    - 하나라도 0을 포함한다면 패킷에 오류가 발생한 것
- 종단간의 원리(end-end principle)
    - 어떤 기능이 종단 기반으로 구현될 때, 하위 레벨에 위치한 기능들은 상위 레벨에서 이들을 제공하는 비용을 비교했을 때, 중복되거나 거의 유용하지 않을 수 있다
- UDP는 오류를 검출하지만 오류를 회복하기 위해 어떤 일도 하지 않음
    1. 손상된 세그먼트를 무시
    2. 경고와 함께 손상된 세그먼트를 애플리케이션에 넘김

```
링크 계층에서 오류 검사를 제공하는데 왜 UDP가 체크섬을 제공할까?

* 링크 계층은 하나의 링크로부터 다른 링크 사이에서만 오류를 검출하고 수정할 수 있다
    * 라우터의 메모리에 저장될 때 비트 오류가 발생 가능
    * 이미 라우터에서 오류를 포함한 패킷이 다음 링크로 넘어가더라도 오류를 검출할 수 없다
* 출발지와 목적지 사이의 모든 링크가 오류 검사를 제공한다는 보장이 없다
```