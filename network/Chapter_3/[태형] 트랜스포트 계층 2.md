## 📚 5. 연결지향형 트랜스포트 : TCP
### 5.3 왕복시간(RTT) 예측과 타임아웃
- rdt 프로토콜처럼 TCP는 손실 세그먼트를 발견하기 위해 타임아웃/재전송 매커니즘을 사용
- TCP에서 타임아웃 주기를 구현할 때 `타임아웃 주기`를 고려해야 함
    - 타임아웃 주기는 RTT보다 좀 더 커야 한다
    - RTT + 처리 시간 + 라우터 지연 시간 + ..

#### 1) 왕복시간 예측
- SampleRTT : `세그먼트 송신 시간 ~ ACK가 도착한 시간`
- 모든 전송된 SampleRTT를 측정하는 대신, 대부분의 `TCP는 한 번에 하나의 SampleRTT 측정`만을 시행
- TCP는 재전송한 세그먼트에 대한 SampleRTT는 계산하지 않고, 한 번 전송된 세그먼트에 대해서만 측정
- 대체로 RTT를 추정하기 위해 `SampleRTT의 평균값`을 사용
- TCP는 SampleRTT의 평균값인 `EstimatedRTT`를 채택
    - SampleRTT를 획득할 때마다 EstimatedRTT를 갱신

#### 2) EstimatedRTT
$$EstimatedRTT = (1-\alpha)\cdot EstimatedRTT + \alpha \cdot SampleRTT$$
- EstiamtedRTT는 SampleRTT의 가중 평균으로 계산
- $\alpha$는 보통 0.125를 사용

```
지수적 가중 이동 평균(EWMA, Exponential Weighted Moving Average)

* 시간에 따른 데이터의 변동성을 예측하고 추적하기 위한 통계 기법
* 최근 데이터에 더 많은 가중치를 부여하면서 과거의 데이터 가중치를 점진적으로 낮추며 평균을 계산
* 파라미터 α
    - EWMA의 민감도를 결정
    - 1에 가까움 : 최근 데이터에 더 큰 가중치 부여 -> 변화에 민감
    - 0에 가까움 : 과거 데이터에 더 큰 가중치 부여 -> 변화에 덜 민감

* 특성
    1. 평화화 : 노이즈가 많은 데이터를 평활화하여 추세를 파악하는 데 유용
    2. 반응 속도 조절 : α를 조절해, 데이터 변화에 대한 반응 속도 조절
    3. 단순성 : 계산이 단순하고, 실시간 데이터 분석에 적합
```

#### 3) DevRTT
$$DevRTT = (1-\beta) \cdot DevRTT + \beta \cdot |SampleRTT - EstimatedRTT|$$
- DevRTT는 SampleRTT와 EstimatedRTT값 차이의 EWMA
-  β는 보통 0.25를 사용

#### 4) 재전송 타임아웃 주기의 설정 및 관리
- EstimatedRTT와 DevRTT 중 TCP 타임아웃 주기에는 어떤 값이 사용되어야 할까?
- EstimatedRTT 이상이 되어야 함
    - 평균보다 낮다면 불필요한 재전송이 많아질 수 있다
    - 너무 크면 세그먼트를 잃어버렸을 때, 즉각적인 재전송을 하지 않게 된다
    - <b>즉, 평균 RTT에서 약간의 여유값을 더하는 것이 바람직하다</b>

$$TiemoutInterval = EstimatedRTT + 4 \cdot DevRTT$$
- SampleRTT의 변동이 큰 경우 -> 여유값이 커져야 함
- SampleRTT의 변동이 작은 경우 -> 여유값이 작아져야 함
- 초기 TimeoutInterval은 보통 1초를 사용
    - 타임아웃이 발생하면, TimeInterval 값을 2배로 하여 조기 타임아웃을 피함
    - 세그먼트가 수신되고 EstimatedRTT가 수정되면 위 공식에 따라 TimeoutInterval을 계산

### 5.4 신뢰적인 데이터 전달
- TCP의 신뢰적인 데이터 전달 서비스는 프로세스가 자신의 수신 버퍼로부터 읽은 데이터 스트림이 손상되지 않았으면 손실이나 중복이 없이 순서가 유지된다는 것을 보장
- 패킷 손실 문제를 해결하기 위한 타이머는 오버헤드가 큼 -> TCCP는 단일 재전송 타이머를 사용
- TCP는 타임아웃이 발생할 때마다 확인응답이 안된 가장 작은 순서번호를 가진 세그먼트를 재전송하고, 주기를 이전 값의 2배로 설정
- 새로운 패킷을 전송할 때는 다시 `TimeoutInterval`은 `EstimatedRTT와 DevRTT`의 가장 최근 값을 가져옴

#### 1) 빠른 재전송
- 긴 타임아웃 주기는 잃어버린 패킷을 다시 보내기 전에 송신자를 오랫동안 기다리게 하여 종단간 지연을 발생시킴
- 송신자는 중복ACK에 의한 타임아웃이 일어나기 전에 패킷 손실을 발견
    - 중복 ACK : 송신자가 이미 이전에 받은 확인응답에 대한 재확인 응답 세그먼트 ACK
    - 중복 ACK가 발생하는 상황
        1. 더 큰 순서번호를 가진 패킷을 받은 경우, 마지막으로 수신된 ACK를 보냄
        2. 송신자는 많은 양의 세그먼트를 동시에 보낼 수 있으므로, 하나의 세그먼트를 잃어버리면 많은 연속적인 중복 ACK가 발생
    - 송신자가 같은 데이터에 대해 3개의 중복 ACK를 수신하면, 3개의 세그먼트가 분실했음을 의미
    - 송신자는 타이머가 만료되기 이전에 손실 세그먼트 재전송을 위한 `빠른 재전송(fast retransmit)`을 수행

#### 2) TCP는 GBN? SR?
- TCP 송신자는 송신되고 `응답되지 않은 가장 작은 순서번호`와 `전송될 다음 바이트의 순서번호`를 유지
- TCP는 GBN과 SR의 혼합

<b>GBN과의 차이</b>
- 대부분의 TCP 구현은 순서가 바뀐 세그먼트를 폐기하지 않고 버퍼링
- n, n+1, n+2, ... 중 n+1 이후의 세그먼트를 수신하면 순서번호 n의 패킷만을 재전송

```
TCP의 선택적 확인 응답 (selective acknowledgment)

"순서가 맞는" 세그먼트에 대해 누적 확인응답을 하기 보다는 "순서가 틀린" 세그먼트에 대해 선택적으로 확인응답한다
```

### 5.5 흐름제어
- TCP 연결의 각 종단에서 호스트들은 연결에 대한 개별 수신 버퍼를 설정
- 프로세스는 버퍼에서 데이터를 읽지만, 데이터가 도달한 시점에 읽어야 할 필요는 없음
- 흐름제어(Flow Control) : `송신자가` 수신자의 버퍼를 오버플로시키는 것을 방지하기 위해 제공
    - 수신하는 애플리케이션이 읽는 속도와 송신자의 전송 속도를 같게 함

#### 1) 수신 윈도우(Receive Window)
- 수신 측에서 가용한 버퍼 공간이 얼마나 되는지를 송신자에게 알려주기 위해 사용
- TCP는 전이중 통신으로, 각 측의 송신자는 별개의 수신 윈도우를 유지 (송신자와 수신자 모두 송신자 입장에서 수신 윈도우를 유지한다)
- 용어
    - RcvBuffer : 수신 버퍼의 크기
    - LastByteRead : 수신 측에서 프로세스에 의해 버퍼로부터 읽힌 데이터 스트림의 마지막 바이트 수
    - LastByteRecvd : 수신 측에서 수신 버퍼에 저장된 데이터 스트림의 마지막 바이트 수

수신 버퍼가 오버플로 되면 안되므로 다음을 만족해야 한다
$$LastByteRecvd - LastByteRead \le RcvBuffer$$

rwnd는 수신윈도우로, 수신 윈도우는 버퍼의 여유 공간으로 설정된다
$$rwnd=RcvBuffer - [LastByteRcvd - LastByteRead]$$

#### 2) 수신 윈도우의 동작
- 수신자는 송신자에게 세그먼트를 전송할 때 현재의 rwnd값을 설정하여 수신 버퍼의 여유 공간을 알림
- 송신자는 `LastByteSent`와 `LastByteAcked`를 유지
    - `LastByteSent - LastByteAcked`는 전송 확인응답이 안된 데이터의 양
    - rwnd의 값보다 작은 값을 유지함으로써 수신 버퍼에 오버플로 발생을 방지

송신측은 다음을 만족한다
$$LastByteSent - LastByteAcked \le rwnd$$

#### 3) 수신 윈도우의 문제
rwnd = 0이 되어 송신을 멈추었다가 프로세스가 수신 버퍼를 비우더라도 송신자 입장에서는 수신버퍼가 비었는지 확인할 수 없음

송신자는 수신자에게 지속적으로 1Byte의 데이터를 전송한다. 버퍼가 비워지면 수신자는 송신자에게 ACK와 0이아닌 rwnd를 응답한다.

### 5.6 TCP 연결 관리
TCP를 이용한 서버와의 TCP 연결 설정

#### 1) 3way handshaking
TCP 연결 설정 과정은 다음과 같다
1. 클라이언트 TCP는 서버 TCP에게 특별한 TCP 세그먼트를 송신한다
    - SYN
    - `SYN=1, seq=client_isn`
2. 서버는 연결에 TCP 버퍼와 변수를 할당한다
    - 클라이언트 TCP로 연결 승인 세그먼트를 송신한다
    - SYN+ACK
    - `SYN=1, ack=client_isn+1, seq=server_isn`
3. 클라이언트는 연결에 버퍼와 변수를 할당한다
    - ACK
    - `SYN=0, ack=server_isn+1 seq=client_isn`
    - 클라이언트에서 서버로 페이로드에 데이터가 운반될 수 있다

연결 설정 이후에는 각 세그먼트들의 SYN=0으로 설정된다

#### 2) 4way handshaking
TCP 연결 해제 과정은 다음과 같다
1. 클라이언트 TCPs는 서버 TCP에게 특별한 세그먼트를 송신한다
    - FIN
2. 서버는 클라이언트에게 ACK를 보낸다
    - ACK
3. 서버는 FIN=1인 종료 세그먼트를 송신한다
    - FIN
4. 클라이언트는 종료 세그먼트에 대한 ACK로 응답한다
    - ACK

#### 3) 서버가 준비되지 않은 경우
1. 클라이언트는 서버로 TCP 연결 설정을 위한 세그먼트를 송신한다
    - SYN
2. 서버는 클라이언트에게 리셋 세그먼트를 송신한다
    - `RST=1`
    - <b>해당 세그먼트에 대한 소켓을 갖고 있지 않으니 세그먼트를 재전송하지 말라</b>