## 📚 5. 연결지향형 트랜스포트 : TCP
### 5.3 왕복시간(RTT) 예측과 타임아웃
- rdt 프로토콜처럼 TCP는 손실 세그먼트를 발견하기 위해 타임아웃/재전송 매커니즘을 사용
- TCP에서 타임아웃 주기를 구현할 때 `타임아웃 주기`를 고려해야 함
    - 타임아웃 주기는 RTT보다 좀 더 커야 한다
    - RTT + 처리 시간 + 라우터 지연 시간 + ..

#### 1) 왕복시간 예측
- SampleRTT : `세그먼트 송신 시간 ~ ACK가 도착한 시간`
- 모든 전송된 SampleRTT를 측정하는 대신, 대부분의 `TCP는 한 번에 하나의 SampleRTT 측정`만을 시행
- TCP는 재전송한 세그먼트에 대한 SampleRTT는 계산하지 않고, 한 번 전송된 세그먼트에 대해서만 측정
- 대체로 RTT를 추정하기 위해 `SampleRTT의 평균값`을 사용
- TCP는 SampleRTT의 평균값인 `EstimatedRTT`를 채택
    - SampleRTT를 획득할 때마다 EstimatedRTT를 갱신

#### 2) EstimatedRTT
$$EstimatedRTT = (1-\alpha)\cdot EstimatedRTT + \alpha \cdot SampleRTT$$
- EstiamtedRTT는 SampleRTT의 가중 평균으로 계산
- $\alpha$는 보통 0.125를 사용

```
지수적 가중 이동 평균(EWMA, Exponential Weighted Moving Average)

* 시간에 따른 데이터의 변동성을 예측하고 추적하기 위한 통계 기법
* 최근 데이터에 더 많은 가중치를 부여하면서 과거의 데이터 가중치를 점진적으로 낮추며 평균을 계산
* 파라미터 α
    - EWMA의 민감도를 결정
    - 1에 가까움 : 최근 데이터에 더 큰 가중치 부여 -> 변화에 민감
    - 0에 가까움 : 과거 데이터에 더 큰 가중치 부여 -> 변화에 덜 민감

* 특성
    1. 평화화 : 노이즈가 많은 데이터를 평활화하여 추세를 파악하는 데 유용
    2. 반응 속도 조절 : α를 조절해, 데이터 변화에 대한 반응 속도 조절
    3. 단순성 : 계산이 단순하고, 실시간 데이터 분석에 적합
```

#### 3) DevRTT
$$DevRTT = (1-\beta) \cdot DevRTT + \beta \cdot |SampleRTT - EstimatedRTT|$$
- DevRTT는 SampleRTT와 EstimatedRTT값 차이의 EWMA
-  β는 보통 0.25를 사용

#### 4) 재전송 타임아웃 주기의 설정 및 관리
- EstimatedRTT와 DevRTT 중 TCP 타임아웃 주기에는 어떤 값이 사용되어야 할까?
- EstimatedRTT 이상이 되어야 함
    - 평균보다 낮다면 불필요한 재전송이 많아질 수 있다
    - 너무 크면 세그먼트를 잃어버렸을 때, 즉각적인 재전송을 하지 않게 된다
    - <b>즉, 평균 RTT에서 약간의 여유값을 더하는 것이 바람직하다</b>

$$TiemoutInterval = EstimatedRTT + 4 \cdot DevRTT$$
- SampleRTT의 변동이 큰 경우 -> 여유값이 커져야 함
- SampleRTT의 변동이 작은 경우 -> 여유값이 작아져야 함
- 초기 TimeoutInterval은 보통 1초를 사용
    - 타임아웃이 발생하면, TimeInterval 값을 2배로 하여 조기 타임아웃을 피함
    - 세그먼트가 수신되고 EstimatedRTT가 수정되면 위 공식에 따라 TimeoutInterval을 계산

### 5.4 신뢰적인 데이터 전달
- TCP의 신뢰적인 데이터 전달 서비스는 프로세스가 자신의 수신 버퍼로부터 읽은 데이터 스트림이 손상되지 않았으면 손실이나 중복이 없이 순서가 유지된다는 것을 보장
- 패킷 손실 문제를 해결하기 위한 타이머는 오버헤드가 큼 -> TCCP는 단일 재전송 타이머를 사용
- TCP는 타임아웃이 발생할 때마다 확인응답이 안된 가장 작은 순서번호를 가진 세그먼트를 재전송하고, 주기를 이전 값의 2배로 설정
- 새로운 패킷을 전송할 때는 다시 `TimeoutInterval`은 `EstimatedRTT와 DevRTT`의 가장 최근 값을 가져옴

#### 1) 빠른 재전송
- 긴 타임아웃 주기는 잃어버린 패킷을 다시 보내기 전에 송신자를 오랫동안 기다리게 하여 종단간 지연을 발생시킴
- 송신자는 중복ACK에 의한 타임아웃이 일어나기 전에 패킷 손실을 발견
    - 중복 ACK : 송신자가 이미 이전에 받은 확인응답에 대한 재확인 응답 세그먼트 ACK
    - 중복 ACK가 발생하는 상황
        1. 더 큰 순서번호를 가진 패킷을 받은 경우, 마지막으로 수신된 ACK를 보냄
        2. 송신자는 많은 양의 세그먼트를 동시에 보낼 수 있으므로, 하나의 세그먼트를 잃어버리면 많은 연속적인 중복 ACK가 발생
    - 송신자가 같은 데이터에 대해 3개의 중복 ACK를 수신하면, 3개의 세그먼트가 분실했음을 의미
    - 송신자는 타이머가 만료되기 이전에 손실 세그먼트 재전송을 위한 `빠른 재전송(fast retransmit)`을 수행

#### 2) TCP는 GBN? SR?
- TCP 송신자는 송신되고 `응답되지 않은 가장 작은 순서번호`와 `전송될 다음 바이트의 순서번호`를 유지
- TCP는 GBN과 SR의 혼합

<b>GBN과의 차이</b>
- 대부분의 TCP 구현은 순서가 바뀐 세그먼트를 폐기하지 않고 버퍼링
- n, n+1, n+2, ... 중 n+1 이후의 세그먼트를 수신하면 순서번호 n의 패킷만을 재전송

```
TCP의 선택적 확인 응답 (selective acknowledgment)

"순서가 맞는" 세그먼트에 대해 누적 확인응답을 하기 보다는 "순서가 틀린" 세그먼트에 대해 선택적으로 확인응답한다
```

### 5.5 흐름제어
- TCP 연결의 각 종단에서 호스트들은 연결에 대한 개별 수신 버퍼를 설정
- 프로세스는 버퍼에서 데이터를 읽지만, 데이터가 도달한 시점에 읽어야 할 필요는 없음
- 흐름제어(Flow Control) : `송신자가` 수신자의 버퍼를 오버플로시키는 것을 방지하기 위해 제공
    - 수신하는 애플리케이션이 읽는 속도와 송신자의 전송 속도를 같게 함

#### 1) 수신 윈도우(Receive Window)
- 수신 측에서 가용한 버퍼 공간이 얼마나 되는지를 송신자에게 알려주기 위해 사용
- TCP는 전이중 통신으로, 각 측의 송신자는 별개의 수신 윈도우를 유지 (송신자와 수신자 모두 송신자 입장에서 수신 윈도우를 유지한다)
- 용어
    - RcvBuffer : 수신 버퍼의 크기
    - LastByteRead : 수신 측에서 프로세스에 의해 버퍼로부터 읽힌 데이터 스트림의 마지막 바이트 수
    - LastByteRecvd : 수신 측에서 수신 버퍼에 저장된 데이터 스트림의 마지막 바이트 수

수신 버퍼가 오버플로 되면 안되므로 다음을 만족해야 한다
$$LastByteRecvd - LastByteRead \le RcvBuffer$$

rwnd는 수신윈도우로, 수신 윈도우는 버퍼의 여유 공간으로 설정된다
$$rwnd=RcvBuffer - [LastByteRcvd - LastByteRead]$$

#### 2) 수신 윈도우의 동작
- 수신자는 송신자에게 세그먼트를 전송할 때 현재의 rwnd값을 설정하여 수신 버퍼의 여유 공간을 알림
- 송신자는 `LastByteSent`와 `LastByteAcked`를 유지
    - `LastByteSent - LastByteAcked`는 전송 확인응답이 안된 데이터의 양
    - rwnd의 값보다 작은 값을 유지함으로써 수신 버퍼에 오버플로 발생을 방지

송신측은 다음을 만족한다
$$LastByteSent - LastByteAcked \le rwnd$$

#### 3) 수신 윈도우의 문제
rwnd = 0이 되어 송신을 멈추었다가 프로세스가 수신 버퍼를 비우더라도 송신자 입장에서는 수신버퍼가 비었는지 확인할 수 없음

송신자는 수신자에게 지속적으로 1Byte의 데이터를 전송한다. 버퍼가 비워지면 수신자는 송신자에게 ACK와 0이아닌 rwnd를 응답한다.

### 5.6 TCP 연결 관리
TCP를 이용한 서버와의 TCP 연결 설정

#### 1) 3way handshaking
TCP 연결 설정 과정은 다음과 같다
1. 클라이언트 TCP는 서버 TCP에게 특별한 TCP 세그먼트를 송신한다
    - SYN
    - `SYN=1, seq=client_isn`
2. 서버는 연결에 TCP 버퍼와 변수를 할당한다
    - 클라이언트 TCP로 연결 승인 세그먼트를 송신한다
    - SYN+ACK
    - `SYN=1, ack=client_isn+1, seq=server_isn`
3. 클라이언트는 연결에 버퍼와 변수를 할당한다
    - ACK
    - `SYN=0, ack=server_isn+1 seq=client_isn`
    - 클라이언트에서 서버로 페이로드에 데이터가 운반될 수 있다

연결 설정 이후에는 각 세그먼트들의 SYN=0으로 설정된다

#### 2) 4way handshaking
TCP 연결 해제 과정은 다음과 같다
1. 클라이언트 TCPs는 서버 TCP에게 특별한 세그먼트를 송신한다
    - FIN
2. 서버는 클라이언트에게 ACK를 보낸다
    - ACK
3. 서버는 FIN=1인 종료 세그먼트를 송신한다
    - FIN
4. 클라이언트는 종료 세그먼트에 대한 ACK로 응답한다
    - ACK

#### 3) 서버가 준비되지 않은 경우
1. 클라이언트는 서버로 TCP 연결 설정을 위한 세그먼트를 송신한다
    - SYN
2. 서버는 클라이언트에게 리셋 세그먼트를 송신한다
    - `RST=1`
    - <b>해당 세그먼트에 대한 소켓을 갖고 있지 않으니 세그먼트를 재전송하지 말라</b>

## 📚 6. 혼잡제어의 원리 ⭐️⭐️⭐️⭐️
- 네트워크가 혼잡해짐에 따라 라우터 버퍼들의 오버플로로 손실이 발생 가능
- <b>네트워크 혼잡 원인을 처리하기 위해서 네트워크 혼잡을 일으키는 송신자를 억제하는 매커니즘이 필요</b>

### 6.1 혼잡의 원인과 비용
- 세 가지 시나리오를 통해 혼잡제어에 대해 공부
- 왜 혼잡이 발생하고 그 혼잡 비용에 대해 공부

#### 1) 2개의 송신자와 무한 버퍼를 갖는 하나의 라우터
- 송신되는 패킷은 무한정 늘어날 수 있지만 수신되는 패킷을 처리하는 데는 한계가 존재
- 라우터의 큐 용량이 무한이라 했을 때, 송신량이 많아질수록 큐에는 데이터가 계속 쌓이게 되고 평균 지연이 무제한이 된다

#### 2) 2개의 송신자와 유한 버퍼를 갖는 하나의 라우터
가정
1. 라우터 버퍼의 양이 유한하다
    - 라우터 버퍼가 가득 찼을 때 도착하는 패킷은 버려짐을 의미
2. 각 연결은 신뢰적이라 가정
    - 패킷이 라우터에서 버려지면 송신자에 의해 재전송됨을 의미

가정 2에서는 재전송이 어떻게 수행되는지에 따라 성능이 달라진다
- 용어
    - $\lambda_{in}$ : 애플리케이션이 원래의 데이터를 소켓으로 보내는 송신율
    - $\lambda_{in}'$ : 원래 데이터와 재전송 데이터를 포함하는 송신율
        - 네트워크에 제공된 부하(offered load)라고 부름, 네트워크로 들어오는 총 데이터를 나타내기 때문에

다음과 같은 경우를 생각할 수 있다
1. 송신자는 라우터의 버퍼가 비었는지 아닌지 알 수 있고, 버퍼가 비어있을 때만 패킷을 송신하는 경우
    - $\lambda_{in}$ = $\lambda_{in}'$, 어떠한 손실도 발생하지 않고 연결의 처리량은 $\lambda_{in}$과 동일
    - 송신된 모든 것이 수신되므로 이상적
    - 평균 호스트 송신율은 R/2를 넘을 수 없다, 수신측의 처리량이 R/2이므로


2. 패킷이 확실히 손실된 것을 알았을 때만, 송신자가 재전송하는 경우
    - 송신자가 사실상 패킷이 손실되었다고 확신할만큼 충분한 타임아웃을 둘 수 있음
    - `송신자는 버퍼 오버플로 때문에 버려진 패킷을 보상하기 위해 재전송을 수행해야 함`
        -> 트래픽을 증가시켜 혼잡을 야기함

3. 송신자에게 너무 일찍 타임아웃되는 바람에 패킷이 손실되지 않고 큐 지연되는 패킷을 재전송하는 경우
    - 원래의 데이터 패킷과 재전송 패킷 모두 수신자에게 도착
    - 수신자는 하나의 패킷만을 필요로하므로 재전송된 패킷을 버림
    - `이미 수신자가 받은 패킷을 라우터가 포워딩하는 것은 리소스의 낭비가 발생`
        -> 트래픽을 증가시켜 혼잡을 야기함

#### 3) 4개의 송신자와 유한 버퍼를 가진 라우터, 그리고 멀티홉 경로
가정
1. 각각의 호스트는 안정적인 데이터 전송을 위해 타임아웃/재전송 매커니즘을 사용
2. 모든 호스트는 동일한 $\lambda_{in}$ 값을 갖고, 모든 라우터 링크는 R bytes/sec 용량을 가진다


- 제공된 부하를 증가하면 처리량이 궁긍적으로 감소하게 된다
- 두 라우터에 대해 두 번째 라우터가 첫 번째 라우터가 전달한 패킷을 버릴 때마다, 첫 번째 라우터는 `헛된 일`을 한 것이 된다
- `패킷이 경로 상에서 버려질 때, 버려지는 지점까지 패킷을 전송하는 데 사용된 상위 라우터에서 사용된 전송용량은 헛된 것이 됨`
    -> 라우터의 리소스가 헛되게 사용되어 정작 필요한 처리를 하지 못하여 혼잡을 야기함

### 6.2 혼잡제어에 대한 접근법
혼잡제어에 대한 TCP의 대략적인 접근법에 대해 공부

#### 1) 종단간의 혼잡제어
- 종단간의 접근법에서 L4는 혼잡제어를 위해 L3에 어떤 직접적인 지원도 제공하지 않음
- 네트워크에서 혼잡의 존재는 단지 관찰된 네트워크 행동에 기초해 종단 시스템이 추측함
    - ex. 패킷 손실 및 지연
- TCP `세그먼트의 손실`은 네트워크 혼잡의 발생으로 생각할 수 있음
    - TCP는 그에 따라 윈도우 크기를 줄인다
- TCP는 `왕복 지연값`을 네트워크 혼잡 증가로 생각할 수 있음

#### 2) 네트워크 지원 혼잡제어
- 네트워크 안에서 혼잡 상태와 관련하여 송신자에게 직접적인 피드백을 제공
- ATM 안에서 ABR(Available Bit Rate) 혼잡제어로 사용됨
    - 자신이 출력 링크에 제공할 수 있는 전송률을 송신자에게 명확히 알릴 수 있게 한다
- XCP 프로토콜 : 라우터가 계산하여 피드백을 제공하도록 함

## 📚 7. 혼잡제어의 원리 ⭐️⭐️⭐️⭐️
TCP는 네트워크 지원 혼잡제어보다는 종단간의 혼잡제어를 사용해야 한다

TCP가 취한 접근 방법
- 네트워크 혼잡 -> 트래픽을 보내는 전송률을 송신자가 제한
- 송신자
    - 목적지까지의 경로에 혼잡이 없음을 감지 -> 송신율을 높임
    - 목적지까지의 경로에 혼잡을 감지 -> 송신율을 줄임
- 의문
    1. 송신자는 트래픽 전송률을 어떻게 제한하는가
    2. 송신자는 자신과 목적지 사이 경로의 혼잡을 어떻게 감지하는가
    3. 송신자는 혼잡이 있을 때 송신율을 변화하기 위해 어떤 알고리즘을 사용하는가

#### 1) 송신자가 트래픽 전송률을 제한하는 방법 & 혼잡을 감지하는 방법
- TCP 호스트들은 송/수신 버퍼와 변수(LastByteRead, rwnd)로 구성
- 송신 측은 혼잡제어 매커니즘을 위한 congestion window를 기록
    - cwnd는 송신자가 네트워크로 트래픽을 전송할 수 있는 비율을 제한

확인응답이 안된 데이터 양은 cwnd와 rwnd의 최솟값을 초과하지 않는다
    -> 둘 중 하나라도 넘어서는 안됨
$$LastByteSent - LastByteAcked \le min({cwnd, rwnd})$$

<br>

가정 : 혼잡 윈도우(congestion window)에 집중하기 위해 rwnd의 제약 조건을 무시할만큼 수신 버퍼가 크다
    - 즉, 확인응답이 안된 데이터의 양은 오로지 cwnd에 의해 한정된다
    - 송신자는 언제나 송신할 데이터를 갖고 있다
    - 혼잡 윈도우 안에 있는 세그먼트들은 송신된다
- 송신자는 제약조건에 따라 cwnd 바이트만큼의 데이터를 송신할 수 있고, RTT가 끝나는 시점에 데이터에 대한 확인응답을 수신함
- 송신자의 송신율은 cwnd/RTT byte/s. cwnd의 값을 조절해 송신율을 조절할 수 있다

<br>

TCP에서 타임아웃 또는 빠른 재전송이 일어났다면 손실 이벤트(loss event)가 발생했다고 정의할 수 있다
- TCP는 확인응답에 따라 손실 이벤트가 발생했다고 판단할 수 있다
    - cwnd의 값을 조절하기 위해 ACK를 사용할 수 있다
- ACK가 상대적으로 늦은 속도로 도착한다면 cwnd는 낮은 속도로 증가
- ACK가 높은 속도로 도착한다면 cwnd는 높은 속도로 증가
- self-clocking : ACK를 cwnd 크기의 증가를 유발하는 트리거 또는 클록으로 사용

#### 2) 송신자가 자신이 송신할 속도를 결정하는 방법
- 전체 TCP 송신자들이 너무 빠른 속도로 송신하면, 네트워크가 혼잡하게 되어 혼잡 붕괴가 나타남
- 너무 낮은 속도로 송신하게 되면 대역폭을 충분히 사용하지 못함

TCP는 다음 처리 원칙에 따라 문제를 해결한다
1. 손실된 세그먼트는 혼잡을 의미하며, 이에 따라 TCP 전송률은 한 세그먼트를 손실했을 때 줄어져야 한다
어떻게 송신자가 cwnd의 크기와 이에 따른 추론된 손실 이벤트에 대응하는 전송률을 줄일지가 문제
2. 확인응답된 세그먼트는 세그먼트가 수신자에게 전송됐다는 것을 의미, 이에 따라 확인응답되지 않은 세그먼트의 ACK가 도착하면, 전송률을 증가시킬 수 있다
3. 대역폭 탐색 : 송신자는 혼잡이 발생하는 시점까지 전송률을 증가시키고, 혼잡이 발생하면 전송률을 감소시킴

### 7.1 TCP 혼잡제어 알고리즘(TCP congestion control algorithm)
알고리즘은 세 가지 구성요소를 갖는다 -> `slow start`, `congestion avoidance`, `fast recovery`
    - 슬로 스타트와 혼잡 회피는 TCP의 필수 요소
    - 수신된 ACK들에 대응하여 cwnd 크기를 얼마나 증가시키는냐는 서로 다름
    - 슬로 스타트는 혼잡 회피보다 
    - 빠른 회복은 권고되지만 TCP 필수사항은 아님

#### 1) 슬로 스타트
- TCP 연결이 초기화될 때, cwnd를 1 MSS로 설정
- 초기 전송률은 `MSS/RTT`
- 응답 확인을 받을 때마다 cwmd를 2배 증가시킴
- 지수적 증가는 언제 종료되는가?
    1. 손실 이벤트(혼잡)가 발생할 경우, cwnd를 1로 설정하고, 다시 슬로 스타트를 시작
        - TCP의 두 번째 상태 변수인 ssthresh(slow start threshold) 값을 cwnd/2로 정함
    2. ssthresh가 cwnd의 절반이므로, 이 값에 도달하거나 지나칠 때 cwnd를 두 배로 증가하는 것은 좋지 못함
        - cwnd값이 ssthresh와 같을 때, 슬로 스타트는 종료되고 TCP는 혼잡 회피 모드로 전환됨
        - 혼잡 회피 모드에서는 cwnd를 조심스럽게 증가시킨다
    3. 3개의 중복 ACK가 검출되면, 빠른 재전송을 수행하여 빠른 회복 상태로 들어간다

```
ssthresh

* 느린 시작이 끝나는 지점을 정하는 기준. 이 값을 넘으면, 데이터를 보내는 속도를 조심스럽게 늘리게 됨

ssthresh가 다시 늘어나는 시점

* 연결의 재설정 : 새로운 연결이 시작되면, ssthresh를 크게 설정
* 네트워크 상태 변화 : 혼잡이 줄어들거나 사라지면, 네트워크 관리자가 ssthresh 값을 조정할 수 있음
* TCP Variants
    - TCP Cubic 같은 특정 TCP 혼잡 제어 알고리즘에서는 네트워크 상태에 따라 ssthresh값을 동적으로 조정 가능
    - 이러한 알고리즘은 네트워크 상태를 분석하여 ssthresh 값을 적절히 조정함
```

#### 2) 혼잡 회피
- cwnd의 값은 혼잡이 마지막 발견된 시점에서의 값의 절반이 된다
- 매 RTT마다 cwnd 값을 두 배로 하기보다는 하나의 RSS만큼 cwnd를 증가
- 선형적 증가는 언제 종료되는가?
    1. 타임아웃이 발생했을 때, cwnd의 값을 1로 하고, ssthresh의 값은 손실 이벤트가 발생할 때의 cwnd의 절반으로 설정
    2. 3개의 중복 ACK가 검출되면, ssthresh를 현재 cwnd의 절반으로 설정하고, 빠른 회복 상태로 전환

#### 3) 빠른 회복
- cwnd값은 잃었던 세그먼트에 대한 매 중복된 ACK를 수신할 때마다 1 MSS만큼씩 증가
- 타임아웃이 발생한다면 슬로 스타트, 혼잡 회피에서와 같은 동작을 수행하고 슬로 스타트로 전이
    - cwnd 값은 1 MSS로 하고, ssthresh값은 손실 이벤트가 발생할 때의 cwnd의 절반으로 설정
- 빠른 회복은 권고 사항이지만 필수는 아니다

#### 4) TCP Tahoe & Reno
1. 느린 시작
    - 초기에 cwnd를 1로 시작하여 매 RTT마다 두 배로 증가시킴
    - ssthresh값에 도달할 때까지 지수적으로 증가
2. 혼잡 회피
    - cwnd가 ssthresh에 도달하면, 이후 선형적으로 증가

##### 차이점
1. 패킷 손실 시 반응
    - Tahoe
        - 타임 아웃 & 세 개의 중복 ACK : cwnd를 1로 줄이고, ssthresh를 현재 cwnd의 절반으로 설정
    - Reno
        - 타임아웃 : cwnd를 1로 줄이고, ssthresh를 현재 cwnd의 절반으로 설정
        - 세 개의 중복 ACK : 빠른 재전송을 수행하고, 빠른 회복 상태로 들어감
        - 느린 시작을 생략하고 혼잡 회피 상태로 전환
2. 효율성
    - Reno는 빠른 회복을 통해 데이터 전송을 보다 빨리 재개할 수 있어 Tahoe보다 효율적으로 작동
    - Tahoe는 항상 느린 시작을 하기 때문에, 혼잡 상황에서 데이터 전송 효율이 떨어질 수 있음