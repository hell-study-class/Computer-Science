## 📚 4. 스위치 근거리 네트워크
- 스위치는 링크 계층에서 동작하기 때문에 링크 계층 프레임을 교환하고, 네트워크 계층 주소를 인식하지 않음
- 2계층 스위치들로 구성된 망에서 경로를 결정할 때는 RIP나 OSRF 같은 라우팅 알고리즘을 사용하지 않음

### 4.1 링크 계층 주소체계와 ARP
- 호스트와 라우터는 네트워크 계층 주소도 가짐
- ARP(Address Resolution Protocol) : IP주소를 링크 계층 주소로 변환

#### 1) MAC 주소
- 실제로 링크 계층 주소를 가진 것은 호스트나 라우터가 아닌 호스트나 라우터의 인터페이스
    - 다수의 네트워크 인터페이스를 가지면 여러 개의 링크 계층 주소를 갖게 됨
    - 링크 계층 스위치는 (호스트나 라우터를 연결해 주는) 인터페이스에 링크 계층 주소를 할당받지 않음
    - ex. 라우터는 우체국, 스위치는 표지판으로 생각 가능. 우체국은 주소를 갖지만 표지판은 주소를 갖지 않음
- MAC 주소(MAC Address) : 링크 계층 주소
    - 길이 : 6Byte, $2^{48}$만큼의 랜주소를 사용 가능
    - 영구적이도록 설계했으나, 소프트웨어로 어댑터(인터페이스)의 주소를 변경 가능
    - 어떤 어댑터도 동일한 주소를 갖지 않음
    - 첫 24비트를 고정하고, 나머지 24비트를 회사에 할당
    - MAC 주소는 변경되지 않고 고정적인 값을 가짐
    - `FF-FF-FF-FF-FF-FF`를 이용하면 브로드캐스트를 날릴 수 있음
- MAC의 기본적인 동작
    1. 송신 어댑터는 프레임에 목적지 어댑터의 MAC 주소를 넣고 랜상으로 전송
    2. 어댑터는 자신을 목적지로 하지 않는 프레임도 수신할 수 있음
        
        2-1. 자신의 MAC주소와 일치한다면 상위 계층으로 데이터그램을 전달

        2-2. 자신의 MAC주소와 일치하지 않는다면 폐기

#### 2) ARP(Address Resolution Protocol)
- ARP : IP주소를 MAC 주소로 변환해줌
- 가정 : 호스트와 라우터는 하나의 IP주소와 하나의 MAC주소를 가짐. 스위치는 모든 프레임을 브로드캐스트
- 송신 호스트는 특정 IP주소를 가진 호스트의 MAC 주소를 알 수 있을까?
    - 송신 호스트가 자신의 ARP 모듈에게 목적지 IP주소 전달 -> 목적지 호스트의 MAC주소 반환
- ARP는 동일한 서브넷 상에서의 IP->MAC 변환을 수행해줌 (다른 서브넷에서는 동작하지 않음)

```
<b>DNS와의 차이</b>

* DNS는 인터넷의 임의 장소에 있는 호스트의 hostname을 해결
* ARP는 동일한 서브넷상에 있는 호스트나 라우터 인터페이스의 IP주소만을 해결
```

#### 3) 서브넷에 있는 노드로의 데이터그램 전송
- 각 호스트와 라우터는 자신의 메모리에 ARP 테이블을 가짐
    - ARP 테이블 : IP주소와 MAC주소 간의 매핑 정보를 포함
    - ARP 테이블은 매핑 정보의 유효기간을 나타내는 TTL을 포함
    - TTL은 보통 20분으로 설정되고, 엔트리의 유효 기간이 종료되면 갱신하거나 다시 추가해야 함
- 테이블은 서브넷 상의 모든 호스트나 라우터 정보를 갖지 않아도 된다

<br>

1. 송신 노드는 `ARP 패킷`이라는 특수 패킷을 구성
    - `송신 및 수신 IP주소`와 `MAC 주소`를 포함하는 필드를 가짐
    - 질의 패킷과 응답 패킷 모두 동일한 포맷을 가짐
2. 호스트는 ARP 질의 패킷을 어댑터에 전달
3. 어댑터는 프레임의 목적지 주소를 `브로드캐스트`로 해서 서브넷으로 전송
4. 브로드캐스트이므로 서브넷 상의 모든 어댑터들은 ARP패킷을 자신의 ARP 모듈로 전달
5. 목적지 IP주소와 ARP패킷의 목적지 주소가 동일한지 검사
6. 일치하는 노드만 요구된 매핑 정보가 포함된 응답 ARP 패킷을 반환하고 나머지는 노드들은 패킷을 폐기

#### 4) 서브넷에 없는 노드로의 데이터그램 전송
가정 : 서브넷에 있는 호스트가 해당 서브넷에 없는 호스트에게 네트워크 계층 데이터그램을 전송하려는 상황
1. 송신 노드는 목적지 IP주소가 동일한 서브넷에 있는지 검사
    - 출발지 IP와 목적지 IP를 서브넷 마스크와 AND 연산을 통해 비교
    - 결과가 다르다면 다른 서브넷에 있는 것을 확인
2. 송신 노드는 라우터의 IP주소로 패킷을 보내야함
    - 이 때, ARP 테이블에 라우터의 MAC주소가 없다면 ARP를 통해 라우터 인터페이스의 MAC주소를 획득
    - 브로드캐스트를 통해 라우터의 주소를 알아내고, 라우터 인터페이스로 유니캐스트로 ARP 메시지를 전송
3. 라우터는 자신의 ARP 테이블에 목적지 IP에 대한 매핑 엔트리가 있는지 확인
4. 라우터는 ARP 요청을 브로드캐스트로 보냄
5. 목적지 노드는 ARP 응답을 라우터에게 유니캐스트로 보냄
6. 라우터는 ARP응답을 받고, B의 MAC주소를 ARP 테이블에 저장

#### 5) ARP의 특징
1. 질의 ARP 메시지는 `브로드캐스트 프레임`으로 전송되지만, 응답 ARP 메시지는 `표준 프레임`(유니캐스트)으로 전송됨
2. ARP는 `플러그 앤 플레이 프로토콜`로, 노드의 ARP 테이블이 자동으로 구축된다

## 📚 7. 총정리: 웹페이지 요청에 대한 처리
전체를 살펴보는 한 가지 방법은 웹 페이지를 다운로드 하는 간단한 요청을 할 때 관련된 프로토콜들을 살펴보는 것

가정: 학교의 이더넷 스위치에 랩톱을 연결하고 웹 페이지(www.google.com)를 다운로드

### 7.1 시작하기: DHCP, UDP, IP 그리고 이더넷
- 학교 라우터는 ISP comcast.net에 연결되어 있음
- DNS 서버는 학교 네트워크가 아닌 Comcast 네트워크에 있음
- DHCP 서버는 라우터에서 실행되고 있음
    - 일반적으로 DHCP 서버는 라우터에서 실행됨

<br>

1. 처음 랩톱을 이더넷 스위치에 연결하면 IP주소 없이는 아무것도 할 수 없음
2. 먼저 DHCP 서버로부터 IP주소를 획득하기 위해 시도
    - `클라이언트`는 DHCP request 메시지를 브로드캐스트한다
        - 목적지 UDP 포트: 67 (DHCP 서버)
        - 출발지 UDP 포트: 68 (DHCP 클라이언트)
        - 목적지 IP: 255.255.255.255
        - 출발지 IP: 0.0.0.0
        - 목적지 MAC: FF:FF:FF:FF:FF:FF
        - 출발지 MAC: 00.16.D3.23.68.8A
    - `DHCP 서버`는 request 메시지를 수신
        - 라우터는 00:22:6B:45:1F:1B인 인터페이스로 DHCP request 메시지를 수신
        - 데이터그램의 브로드캐스트 IP 목적지 주소는 이 데이터그램이 처리되어야 함을 의미함
        - 데이터그램의 페이로드를 역다중화를 통해 상위 계층으로 올라감
        - DHCP 서버는 DHCP request 메시지를 획득
    - `DHCP 서버`는 ACK 메시지를 송신
        - DHCP 서버는 CIDR 블록 68.85.2.0/24에 있는 IP 주소를 할당할 수 있다고 가정
        - DHCP 서버는 클라이언트에게 68.85.2.101을 할당한다고 가정
        - DHCP ACK 메시지 생성. 메시지는 다음을 포함
            - DHCP 서버의 IP: 68.87.71.226
            - 디폴트 게이트웨이 라우터의 IP주소: 68.85.2.1
            - 서브넷 블록: 68.85.2.0/24
            - 출발지 MAC: 00:22:6B:45:1F:1B (라우터 인터페이스)
            - 목적지 MAC: 00:16:D3:23:68:8A
        - 유니캐스트를 통해 클라이언트에게 송신
     - `클라이언트`는 프레임을 수신
        - 프레임 -> IP 데이터 그램, IP 데이터 그램 -> UDP 세그먼트, UDP 세그먼트 -> DHCP 메시지
        - <b>자신의 IP주소와 DNS 서버의 IP주소를 기록</b>
        - <b>IP 포워딩 테이블에 디폴트 게이트웨이 주소를 저장</b>
```
DHCP를 사용할 때는 DHCP 4단계 중 마지막 두 단계만 실제로 필요함
```

### 7.2 여전히 시작하기: DNS와 ARP
브라우저에 URL로 www.google.com을 입력했을 때, HTTP 요청 메시지를 보내기 위해 TCP 소켓을 생성하는 절차를 시작한다.

소켓을 생성하기 위해서 클라이언트는 www.google.com의 IP주소를 알아야 한다.

3. `클라이언트`는 DNS 질의 메시지를 생성
    - 질의 메시지의 질문 부분(question section)에 www.google.com을 넣음
        - 목적지 UDP 포트: 53
        - 출발지 UDP 포트: 68
        - 목적지 IP: 68.87.71.226 (DHCP ACK로부터 받은 DNS 서버의 주소)
        - 출발지 IP: 68.85.2.101
        - 목적지 MAC:
        - 출발지 MAC: 00.16.D3.23.68.8A
4. `클라이언트`는 DNS 질의 메시지를 보내기 위해 ARP를 통해 게이트웨이의 MAC 주소를 획득
    - DHCP ACK를 통해 라우터의 IP주소를 알았지만, MAC주소는 알 수 없음
    - 클라이언트는 ARP 질의 메시지를 생성
        - 목표 IP: 68.85.2.1
        - 목적지 MAC: FF:FF:FF:FF:FF:FF
        - 출발지 MAC: 00.16.D3.23.68.8A
    - 라우터는 68.85.2.1에 대응하는 MAC 주소인 00:22:6B:45:1F:1B를 포함한 ARP 응답 메시지를 생성
        - 목적지 MAC: 00.16.D3.23.68.8A
        - 출발지 MAC: 00:22:6B:45:1F:1B
    - 클라이언트는 게이트웨이 라우터의 MAC 주소를 추출
5. 클라이언트는 게이트웨이 라우터의 MAC주소로 3에서 생성한 DNS 질의 메시지를 송신
    - 이 때, 목적지 MAC 주소는 게이트웨이 라우터의 MAC 주소가 된다
    - 질의 메시지의 질문 부분(question section)에 www.google.com을 넣음
        - 목적지 UDP 포트: 53
        - 출발지 UDP 포트: 68
        - 목적지 IP: 68.87.71.226 (DHCP ACK로부터 받은 DNS 서버의 주소)
        - 출발지 IP: 68.85.2.101
        - 목적지 MAC: `00:22:6B:45:1F:1B`
        - 출발지 MAC: 00.16.D3.23.68.8A

7.3 여전히 시작하기: DNS서버로의 인트라-도메인 라우팅
5. 게이트웨이 라우터는 프레임을 받아서 DNS 질의가 포함된 데이터그램을 추출
    - 목적지 IP: 68.87.71.226 (DHCP ACK로부터 받은 DNS 서버의 주소)를 포워딩 테이블에서 찾음
    - 콤캐스트 라우터로 연결하는 링크로 프레임을 전송
6. 콤캐스트 라우터는 목적지 주소와 포워딩 테이블로부터 데이터를 DNS 서버로 전달할 인터페이스를 결정
7. DNS 질의가 포함된 IP 데이터그램이 DNS 서버에 도착
    - DNS 질의 메시지로부터 question section에 있는 데이터의 DNS 자원 레코드를 찾음
    - DNS 서버는 호스트 이름에 대한 IP주소 정보를 포함하는 DNS 응답 메시지를 송신
8. 클라이언트는 DNS 메시지로부터 www.google.com의 IP주소를 획득

### 7.4 웹 클라이언트-서버 상호작용: TCP와 HTTP
9. 클라이언트는 서버와 연결하기 위해 TCP 소켓을 생성하고 3way handshaking을 시도
    - TCP SYN 세그먼트를 생성
    - 목적지 IP: 64.223.169.105 (www.google.com)
    - 출발지 IP: 68.85.2.101
    - 목적지 MAC: 00:22:6B:45:1F:1B (라우터 게이트웨이의 MAC)
    - 출발지 MAC: 00.16.D3.23.68.8A

10. 서버는 SYN 세그먼트를 수신
    - TCP SYN 세그먼트는 데이터그램으로부터 추출되어 포트80과 연관된 welcome 소켓으로 역다중화
    - 클라이언트와의 연결을 위해 연결 소켓 생성
    - TCP SYNACK 메시지를 송신

11. 클라이언트는 서버로부터의 SYNACK 메시지를 수신
    - 구글 -> 콤캐스트 -> 학교 네트워크를 통해 전달됨
    - 데이터그램은 운영체제에서 9에서 생성한 소켓으로 역다중화

12. 클라이언트와 서버의 연결 설정이 완료되고 클라이언트는 HTTP GET 메시지를 송신

13. 서버는 TCP 소켓으로부터 HTTP GET 메시지를 읽고, 요청한 데이터를 포함한 HTTP 응답 메시지를 송신

14. 클라이언트는 웹 페이지를 읽을 수 있게 됨